*) Namespace:
    -> In kubernetes cluster you can organize resources in namespaces.
    -> it's means that you can have multiple resources a namespaces.
    -> You can think of a namespace as a Virtual cluster inside of a kubernetes cluster.
    -> By default kubernetes gives you the 4 namespace out of the box.
        ❯ kubectl get ns
        ❯ kubectl get namespace
            NAME              STATUS   AGE
            default           Active   13h
            kube-node-lease   Active   13h
            kube-public       Active   13h
            kube-system       Active   13h
        
        -> Now let's go through them one by one:
            1. kube-system: './02_kube-system_namespace.png'
                -> not meant for you use, Do not create or modify in kube-system.
                -> the components that are deployed inside the namespace are:
                    a. System processes
                    b. Master and kubectl processes
                    etc...
            2. kube-public: './03_kube-public_Namespace.png'
                -> contain the publicly accessible data
                -> it has a config map that contains cluster information which is accessible even without authentication.
                -> so of we will do:
                    -> kubectl cluster-info
                        -> (we can get some information of cluster)
            3. kube-node-lease: './04_kube-node-lease_Namespace.png'
                -> It's holds information about the heartbeats of nodes.
                -> so each node get's it's object contains the information about that nodes availability
            4. default: './05_default_Namespace.png'
                -> this is the namespace that we are going to be using to create resource at the beginning if we have not create the new/custom namespace
    
    *) Create Namespace:
        -> kubectl create namespace <Namespace_name>
        -> EX: kubectl create namespace my-namespace
        -> Another way to create namespace is by using namespace configuration file, which is the better way to create namespaces.
            -> EX: we have create the './prod-namespace.yaml' file
            -> which we will use any where by another developer now
            -> now just create it:
                -> kubectl apply -f .\prod-namespace.yaml
            -> Now we will use this namespace to create other resources

    *) Use cases of Namespace: 
        1. Everything in one namespace
            -> './06_Why_namespace.png', './07_Why_namespace.png'
            -> imagine you have default namespace that is create by default and you create every resources inside that same namespace and if you have a complex application, that have multiple deployments which create replicas of many Pods and you have resources like 'services' & 'configMap' etc..., very soon your default namespace will going to be filled with different components and it will be very difficult to have and overview of what's in there especially with multiple user creating resources inside. so better way to use namespace in this case is to group resources into namespaces
            -> For example you could have a 'Database' namespace where you deploy database and all it's required resources are deployed inside that namespace.
            -> Another namespace could be 'Nginx-Ingress'
            -> So it is one way of logically grouping your resources inside you cluster.
            -> official documentation of kubernetes say not to use namespaces for Smaller projects and upto 10 users.
            -> but it is a good ideas to group your resource in different namespaces.
        2. Conflict: Many teams, Same application
            -> './08_Why_namespace.png'
            -> Another use case could be if you have multiple teams working on.
            -> imagine you have a times that is using same cluster. and one team deploy and application called 'my-app deployment' and that deployment have certain configuration
            -> And another team have deployment which name is same as previous team 'my-app deployment' with different  configuration and they created the deployment and they apply it, then they will override the first team deployment.
            -> So, to avoid such kind of conflicts again you can use namespaces so that each team can work in their own namespace without disrupting the other.
        3. Resource Sharing: Staging and Developing
            -> './09_Resource_Sharing.png', './10_Resource_Sharing.png'
            -> Let's say you have One cluster and you want to host Staging and development environment into the same cluster and the reason for that is for example if you are using "Nginx Controller" or "Elastic Stack" you can deploy it in one cluster and re-use those component in both "Staging" & "development" environment.
            -> In that way you don't have to deploy this common resources twice in two different clusters. 
        4. Resource Sharing: Blue/Green Deployment
            -> './11_Resource_Sharing.png', './12_Resource_Sharing.png'
            -> It means that in the same cluster you want to have two different version of Production running.
            -> So, one that is Active Production and another one will be on the Next Production version.
            -> And these namespace Two or multiple production version could be using the same Resources in that case as well we can use namespace.
        
        5. Access and Resource Limits on Namespace.
            a.
                -> './13_Access_and_Resource_Limits_on_Namespaces.png'
                -> Let's say we have scenario where we have two teams working on the same cluster and each one of them and Each one of them have their own namespace, So in this scenario what we can do is we can give the teams access only their namespaces so that they are only be able to create, update, delete resource in their own namespaces But they should not be able to do any thing to other namespace.
                -> In this way we restrict and minimize the risk of one team accidentally interfering with another teams works.
                -> So each teams will work with their own isolated environment.

            b. Limit the Resource that each namespace use:
                -> './14_Access_and_Resource_Limits_on_Namespaces.png'
                -> Another thing that we can do is we can limit the resource that each namespace use like: CPU, RAM, Storage Per Namespace.
                -> If you have a cluster with limited resources that each team share of resources for their application.
                -> For Per namespace we can define Resource Quota that limit how much CUP, RAM & Storage resources one namespace can use.
                
    *) Characteristics that we should consider before deciding how to group and how to use Namespace:
        1. You can't access most of resource from another Namespace.
            -> './15_Characteristics_of_Namespace.png'
            -> For example you have ConfigMap in "Project A" namespace that reference the "DB" service namespace you can't not use that ConfigMap in "Project B" namespace
            -> For that you have to create the same ConfigMap that also references the "DB" Service
            -> So, each namespace Must define own ConfigMap
            -> Also, Same apply to Secret of Shared service for that also we have to a create a Secret in Each Namespaces. Where you are going to need that.
        2. Access Service in Another Namespace.
            -> './17_Access_Service_in_Another_Namespace.png'
            -> However the resource that you can share across the namespace is Service.
            -> So ConfigMap in "Project B" Namespace is references Service "mysql-service" in "database" namespace that will use eventually in a pod.
            -> And the way that it works is that In ConfigMap Definition In addition to it's name which is in this case 'mysql-service' will have namespace at the end
                data:
                    db_url: mysql-service.database
            -> And using this you can access services form another namespaces
        3. Components, which can't be create within a Namespace:
            -> './18_Component_which_Can_not_Be_In_Namespace.png'
            -> We show that most of the components can be created inside the namespaces But there are some components in kubernetes which they are not Namespaced
            -> So they will live globally in the cluster
            -> And you can't isolate them and put then in a Namespace
            -> EX: Volume or Persistent Volume and Node
            -> and we have a command that we can use to list out all the components that we can't Namespaced
                -> kubectl api-resources --namespaced=false
            -> And also we have command that we can use to list out all the components that we can Namespaced
                -> kubectl api-resources --namespaced=true
                
    *) Create Component in Namespace:
        -> Be default if we don't provide the namespace on Configuration file it will use the 'default' name space and create those component inside there.
        -> so './mongo-configmap.yaml' configMap configuration create configMap on default namespace we can check all the component that are applied on given namespace
        -> for now we will check of the configMap component
        -> kubectl get <component_name> -n <namespace_name>
            -> EX: kubectl get configmap -n default
            
        -> './19_Create_Component_in_Namespace.png'
        -> One Way to create configMap on specific namespace you can do:
            -> kubectl apply -f .\<configMap_filename>.yaml --namespace=<namespace_name>
                -> EX: kubectl apply -f .\mongo-configmap.yaml --namespace=my-namespace
        
        -> Another way to create component inside specific namespace is by providing the 'namespace' on 'metadata'
            metadata:
              name: mongodb-configmap
              namespace: my-namespace
              
        -> kubectl get configmap -n my-namespace
            NAME                DATA   AGE
            kube-root-ca.crt    1      74m
            mongodb-configmap   1      2m41s

        
        -> Note: best practice is to provide namespace inside the configuration file over kubectl command because one it is better documented and second if we are using automated deployment then you will just apply the configuration file and this would be more convenient way to do it.
        

    *) Change the active namespace with kubens:
        -> for a scenario where One team get their own namespace and have to work means to create component entirely in that namespace the it would be annoying to have to add '-n <namespace>' tag to every 'kubectl' command
        -> So in order to make it more convenient there is a way to change this default or active namespace which is 'default' namespace provided by the kubernetes to whatever namespace you want.
        -> And for that we can use the third party tools like 'kubens': https://github.com/ahmetb/kubectx
            -> Install windows:
                -> winget install --id ahmetb.kubectx
                -> winget install --id ahmetb.kubens
            -> Command:
                -> kubens (command to see all the namespace and highlight the active one)
                -> kubens my-namespace (command to switch to another namespace as active)
        -> Also we can achieve with bellow command:
            -> kubectl config set-context --current --namespace=[namespaceName]
            
    *) Other commands:
        -> kubectl get pods --all-namespaces
            -> (get all the pods according to it's namespace that it is running)
            default       mongo-express-58b7cb7879-sb5pl        1/1     Running   0             10h
            default       mongodb-deployment-84d7c8b6dd-w47pl   1/1     Running   0             11h
            kube-system   coredns-5d78c9869d-pw6tl              1/1     Running   0             15h
            kube-system   etcd-minikube                         1/1     Running   0             15h
            kube-system   kube-apiserver-minikube               1/1     Running   0             15h
            kube-system   kube-controller-manager-minikube      1/1     Running   0             15h
            kube-system   kube-proxy-l5bjl                      1/1     Running   0             15h
            kube-system   kube-scheduler-minikube               1/1     Running   0             15h
            kube-system   storage-provisioner                   1/1     Running   1 (15h ago)   15h
        -> kubectl get services --all-namespaces