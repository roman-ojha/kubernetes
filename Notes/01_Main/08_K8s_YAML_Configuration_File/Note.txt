*) 3 Parts of a K8s Configuration file
    1. Metadata: './01_First_Part_of_Configuration_File.png'
    2. Specification: './02_Second_Part_of_Configuration_File.png'
        -> where we put every kind of Configuration you want to apply for that Component
    3. Status:
        -> It will be automatically generated and add by kubernetes
        -> So kubernetes will always compare like 'what is the desired state?', and 'what is the actual state or status of that component?'
        -> and if the actual state and the desired state don't match so kubernetes knows there is something needs to be fixed
        -> Ex: './04_Third_Part_of_Configuration_File.png', './05_Third_Part_of_Configuration_File.png'
            -> if you have specify the 'replicas' as 2 then kubernetes will add status of you deployment and it will update the state continuously
            -> and if status says 1 replica is running then kubernetes will compare that status with the specification and it will know there is a problem there that another replica needs to be created because new specification says 2 replica
        
        *) Where does K8s get this status data?
            -> all the information are stored inside the 'control-plane(master)' Node 'etcd' Process that we talk before inside '../05_K8s_Architecture/Note.txt'
            -> Etcd holds the current status of any K8s component

*) Configuration file:
    -> Note that yaml syntax  are strict indentation 
    -> for the indentation we can use yaml online validator or IDE like vscode with extension feature
    -> Store the config file with your code or own git repository


*) Blueprint for Pods
    -> './07_Pod_Template.png'
    -> So we have understand that Deployment handle all the layer of other stuff like "ReplicaSet", "Pod", "Container" underneath it
    -> So it is defining under the 'spec -> template' inside deployment configuration file
    -> it would contain like:
        -> which image it should be based on?
        -> which port it should open on?
        -> the name of the container? etc ...


*) Labels & Selectors:
    -> so we can see on './nginx-deployment.yaml' & './nginx-service.yaml' that:
        1> 'metadata' part contain labels './08_Labels.png'
            -> './10_Labels.png'
            -> in metadata we give component like 'labels' in any key-value pair
            -> it could be any key value pair, in this case we have use 'app: nginx'
            -> and this label stick to that component
            -> So we give Pods created using 'template' Blueprint where labels is 'app: nginx' './11_Labels_Template.png'
            -> and we tell the deployment to connect and to match all the labels with 'app: nginx' to create that connection './12_Connecting_Deployment_To_Pods.png'
            -> This is way deployment will know which Pods belong to it.
        2> 'specification' part contain selectors './09_Selectors.png'
            -> So deployment have it's own label 'app: nginx''./13_Deployment_Label.png'
            -> And These 2 label 'deployment' & 'Pod' label are use to apply the service Selector
            -> So, in service we define a selector that will make a connection between the service and the deployment or its Pods './14_Connecting_Services_to_Deployments.png'
            -> So service need to know which pods are registered or belongs to that service and that is happening through the selector of that label.
    *) Ports in Service and Pod:
        -> So the another this that needs to be configured on Service and Pod is Port.
        -> so on './nginx-service.yaml' we can see that it have 'ports' configuration
        -> also './nginx-deployment.yaml' on the container inside of a Pod needs to run on a Port specify on 'ports'.
        -> So, Service has it's own port where service itself is accessible at.
        -> So, by any other Service request to ex:'nginx' Service and that request needs to send on 'port: 80' But the Service needs to know which Pod it's should forward the request and also which Port it is listening and that is the 'targetPort' which is in this case '8080', './15_Ports_in_Service_and_Pod.png'
    
=> Above explain example are the minimum configuration that we need to do to run deployment and service


*) Creating deployment and service:
    -> kubectl apply -f .\nginx-deployment.yaml
    -> kubectl apply -f .\nginx-service.yaml
    
    ->  kubectl get services
        NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
        kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP   155m
        nginx-service   ClusterIP   10.104.130.184   <none>        80/TCP    46s
        -> here 'kubernetes' service is the default service that will get create
        -> here on 'nginx-service' it is listening on PORT '80' as we can see
        
    -> kubectl describe service <Name_of_service>
        -> (using this command we can see all the information also we can validate that the service have the right pods that it forwards it's request to)
        Name:              nginx-service
        Namespace:         default
        Labels:            <none>
        Annotations:       <none>
        Selector:          app=nginx
        Type:              ClusterIP
        IP Family Policy:  SingleStack
        IP Families:       IPv4
        IP:                10.105.80.229
        IPs:               10.105.80.229
        Port:              <unset>  80/TCP
        TargetPort:        8080/TCP
        Endpoints:         10.244.0.15:8080,10.244.0.16:8080,10.244.0.17:8080
        Session Affinity:  None
        Events:            <none>
        -> (Now inside 'Endpoints' we have three Endpoints because that much amount of pods that we create)
        -> (and 'Endpoints' must be the Ip address and Ports of the Pods that the service most forward the request to)
        -> (Using the bellow command to check the IpAddress of the pod we can verify that these Endpoints match with the ip address of all the pods)
        
    -> kubectl get pod -o wide
        -> -o: output
        -> (using this we can see the more detail version of pods and also see the Ip address of every Pods that it's runs on)
        NAME                               READY   STATUS    RESTARTS   AGE     IP            NODE       NOMINATED NODE   READINESS GATES
        nginx-deployment-fb5cffcd6-2k2wx   1/1     Running   0          3m19s   10.244.0.16   minikube   <none>           <none>
        nginx-deployment-fb5cffcd6-vsg68   1/1     Running   0          3m19s   10.244.0.17   minikube   <none>           <none>
        nginx-deployment-fb5cffcd6-xqlt4   1/1     Running   0          3m19s   10.244.0.15   minikube   <none>           <none>


*) Check the Status:
    -> kubectl get deployment nginx-deployment -o yaml
        -> -o yaml: output in yaml format
        -> (Using this command we can get the updated configuration of the deployment with 'status' which is stored inside the 'etcd' of the Master Node)
        
    -> kubectl get deployment nginx-deployment -o yaml > <deployment_result_file_name>.yaml
        -> Ex: kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml
        -> (using this we can store that yaml output into file)
        -> inside './nginx-deployment-result.yaml' we can see that it added an 'status' as well as other important information related to the Component
        
*) Delete Deployment & Service using configuration file:
    -> kubectl delete -f .\<Deployment_file_name>.yaml (to delete Deployment)
    -> kubectl delete -f .\nginx-service.yaml (delete service)